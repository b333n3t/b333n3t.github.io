<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>b3nn3t • Baseline (kein Bild nötig)</title>
<style>
  :root{ --bg:#333333; }
  html,body{margin:0;height:100%;background:var(--bg);overflow:hidden}
  canvas{display:block;width:100vw;height:100vh;image-rendering:pixelated;image-rendering:crisp-edges}
</style>
</head>
<body>
<canvas id="stage"></canvas>
<script>
(function(){
  "use strict";

  // ===== Flags (alles an) =====
  const RUN_TO_RIGHT   = true;
  const WORD           = "b3nn3t";
  const LETTER_GAP     = 16;   // in PX()
  const LETTER_SIZE    = 16;   // in PX()
  const HEAD_SCALE     = 26;   // größerer Kopf
  const BODY_SCALE     = 16;
  const HAMMER_MS      = 380;
  const SPARKS_PER_HIT = 10;

  // ===== Canvas init =====
  const cvs = document.getElementById("stage");
  const ctx = cvs.getContext("2d");
  let W=0, H=0, DPR=1, frameCount=0, lastErr="";
  function PX(){ return Math.max(2, Math.floor(Math.min(W,H)/240)); }
  const lineY = () => Math.floor(H*2/3);
  const lineEndX = () => Math.floor(W*0.82);

  function resize(){
    try{
      DPR = Math.max(1, window.devicePixelRatio || 1);
      W = cvs.width  = Math.floor(innerWidth  * DPR);
      H = cvs.height = Math.floor(innerHeight * DPR);
      cvs.style.width  = innerWidth  + "px";
      cvs.style.height = innerHeight + "px";
      ctx.imageSmoothingEnabled = false;
    }catch(e){ lastErr = "resize:"+(e.message||e); }
  }
  addEventListener("resize", resize); resize();

  // ===== Debug overlay =====
  function debug(){
    ctx.save();
    ctx.font = '12px monospace';
    ctx.fillStyle = 'rgba(255,255,255,.85)';
    const txt = `frame:${frameCount}  W:${W} H:${H} DPR:${DPR}` + (lastErr?`  ERR:${lastErr}`:'');
    ctx.fillText(txt, 8*PX(), 10*PX());
    ctx.restore();
  }

  // ===== Helpers =====
  function rect(x,y,w,h,fill){
    ctx.fillStyle = fill; ctx.fillRect(x,y,w,h);
    ctx.fillStyle = '#000';
    ctx.fillRect(x-1,y,w+2,1);
    ctx.fillRect(x-1,y+h-1,w+2,1);
    ctx.fillRect(x-1,y,1,h);
    ctx.fillRect(x+w-1,y,1,h);
  }
  function drawLine(){
    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2*PX();
    ctx.beginPath(); ctx.moveTo(0, lineY()); ctx.lineTo(lineEndX(), lineY()); ctx.stroke();
  }

  // ===== Avatar (nur Canvas, kein Bild) =====
  const avatar = {
    state:'walk',
    x: RUN_TO_RIGHT ? -40*PX() : W+40*PX(),
    y: lineY() - 3*PX(),  // Stiefel 3*PX hoch
    vx: RUN_TO_RIGHT ? 2.2 : -2.2,
    vy:0, gravity:.35, step:0,
    headScale:HEAD_SCALE, bodyScale:BODY_SCALE,
    hammerUntil:0
  };

  function drawHead(x,y){
    const p=PX(), s=avatar.headScale*p, w=s, h=s;
    const top = y - avatar.bodyScale*p - s - 2*p;
    // Platzhalter-Kopf (blond/blauäugig)
    rect(Math.round(x-w/2), Math.round(top), w, Math.round(h*.62), '#caa134'); // Haare
    rect(Math.round(x-w/2), Math.round(top+h*.45), w, Math.round(h*.50), '#f2b59a'); // Gesicht
    ctx.fillStyle = '#1a5cff';
    ctx.fillRect(Math.round(x-w*0.1), Math.round(top+h*0.62), 2*p, 2*p);
    ctx.fillRect(Math.round(x+w*0.02), Math.round(top+h*0.62), 2*p, 2*p);
  }

  function drawBody(x,y){
    const p=PX(), bodyH=avatar.bodyScale*p, bodyW=Math.round(10*p);
    const legLen=Math.round(12*p), armLen=Math.round(9*p);
    const torsoX=Math.round(x-bodyW/2), torsoY=Math.round(y-bodyH);
    rect(torsoX,torsoY,bodyW,bodyH,'#2b3a56');

    const hammering = performance.now() < avatar.hammerUntil;
    const armTh=3*p, legTh=4*p;
    const armSwing = hammering ? (Math.sin(Math.PI)*-2*p) : Math.sin(avatar.step)*1.2*p;

    // Arme
    rect(Math.round(x+4*p), torsoY+Math.round(3*p)+Math.round(armSwing), armTh, armLen, '#2b3a56');
    rect(Math.round(x-7*p), torsoY+Math.round(3*p)-Math.round(armSwing), armTh, armLen, '#2b3a56');

    // Beine
    const legSwing = Math.sin(avatar.step)*1.2*p;
    rect(Math.round(x+1*p), y - legLen + Math.round(legSwing), legTh, legLen, '#233047');
    rect(Math.round(x-4*p), y - legLen - Math.round(legSwing), legTh, legLen, '#233047');

    // Stiefel (Unterkante = Linie)
    rect(Math.round(x+1*p), Math.round(lineY()-3*p), 7*p, 3*p, '#7a4f1f');
    rect(Math.round(x-4*p), Math.round(lineY()-3*p), 7*p, 3*p, '#7a4f1f');

    // Hammer
    if (hammering){
      const hx = Math.round(x + 10*p);
      const hy = Math.round(torsoY + 7*p);
      ctx.fillStyle = '#7a4f1f'; ctx.fillRect(hx, hy, 1*p, 9*p);
      ctx.fillStyle = '#c0c0c0'; ctx.fillRect(hx-3*p, hy, 7*p, 2*p);
      ctx.fillStyle = '#000';
      ctx.fillRect(hx-3*p-1, hy, 1, 2*p);
      ctx.fillRect(hx+7*p-1, hy, 1, 2*p);
      ctx.fillRect(hx-3*p-1, hy-1, 7*p+2, 1);
      ctx.fillRect(hx-3*p-1, hy+2*p-1, 7*p+2, 1);
    }
  }

  // Bodenschatten beim Fallen
  function drawFallShadow(){
    if(avatar.state!=='fall') return;
    const p=PX();
    const baseY = lineY() + 2*p;
    const dist  = Math.max(0, avatar.y - lineY());
    const maxW  = 26*p, minW = 10*p;
    const w = Math.max(minW, maxW - dist*0.15);
    const h = Math.max(2*p, 6*p - dist*0.08);
    const alpha = Math.max(0.05, Math.min(0.35, 0.35 - dist*0.0015));
    ctx.save();
    ctx.translate(Math.round(avatar.x), Math.round(baseY));
    ctx.scale(w, h);
    ctx.beginPath();
    ctx.fillStyle = `rgba(0,0,0,${alpha.toFixed(3)})`;
    ctx.arc(0,0,1,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // ===== Buchstaben (spawnen exakt an Avatar-Position, bleiben stehen) =====
  let baseX=null;
  function ensureBaseX(){
    if(baseX!==null) return;
    const spacing=LETTER_GAP*PX();
    const width=(WORD.length-1)*spacing;
    baseX = Math.round(W/2 - width/2);
  }
  function letterX(i){ ensureBaseX(); return baseX + i*LETTER_GAP*PX(); }
  function letterY(){ const p=PX(); const s=avatar.headScale*p; return avatar.y - avatar.bodyScale*p - s*0.35; }

  const letters=[]; // {ch,x,y}
  let nextIndex=0;

  // Funken
  const sparks=[];
  function spawnSparks(x,y){
    const p=PX();
    for(let i=0;i<SPARKS_PER_HIT;i++){
      const ang = Math.random()*Math.PI - Math.PI/2;
      const spd = (0.8+Math.random()*0.8)*6*p;
      sparks.push({x,y,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd-1*p,life:450+Math.random()*250,t:performance.now(),a:1});
    }
  }
  function updateSparks(){
    const now=performance.now(), p=PX();
    for(let i=sparks.length-1;i>=0;i--){
      const s=sparks[i], dt=now-s.t;
      if(dt>s.life){sparks.splice(i,1);continue;}
      s.vy+=0.02*p; s.x+=s.vx*0.016; s.y+=s.vy*0.016; s.a=1-(dt/s.life);
    }
  }
  function drawSparks(){
    const p=PX();
    for(const s of sparks){
      ctx.globalAlpha=Math.max(0,Math.min(1,s.a));
      ctx.fillStyle='#ffd966';
      ctx.fillRect(Math.round(s.x/p)*p, Math.round(s.y/p)*p, 2*p, 2*p);
    }
    ctx.globalAlpha=1;
  }

  function maybeHammerNext(){
    if(nextIndex>=WORD.length) return;
    const tx = letterX(nextIndex);
    const reach = 8*PX();
    if( (RUN_TO_RIGHT && avatar.x >= tx-reach) || (!RUN_TO_RIGHT && avatar.x <= tx+reach) ){
      const ty = letterY();
      letters.push({ch: WORD[nextIndex], x: tx, y: ty});
      avatar.hammerUntil = performance.now() + HAMMER_MS;
      spawnSparks(tx, ty);
      nextIndex++;
    }
  }
  function drawLetters(){
    const p=PX(); ctx.font=(LETTER_SIZE*PX())+'px monospace'; ctx.textBaseline='middle';
    for(const L of letters){
      ctx.lineWidth=2*p; ctx.strokeStyle='#000'; ctx.strokeText(L.ch, Math.round(L.x), Math.round(L.y));
      ctx.fillStyle='#f2f2f2'; ctx.fillText(L.ch, Math.round(L.x), Math.round(L.y));
    }
  }

  // ===== Loop =====
  function tick(){
    try{
      frameCount++;
      ctx.clearRect(0,0,W,H);
      drawLine();

      maybeHammerNext();            // Buchstabe genau an Position erzeugen
      updateSparks();
      drawLetters();
      drawSparks();

      // Bewegung / Fallen
      const p=PX(), speed=avatar.vx*p;
      if(avatar.state==='walk'){
        avatar.x += speed;
        avatar.step += .15;
        avatar.y = lineY() - 3*p + Math.round(Math.sin(avatar.step*2) * 0.5*p);
        if( (RUN_TO_RIGHT && avatar.x >= lineEndX()-6*p) || (!RUN_TO_RIGHT && avatar.x <= lineEndX()+6*p) ){
          avatar.state='fall'; avatar.vy=0;
        }
      }else if(avatar.state==='fall'){
        avatar.vy += avatar.gravity*p*.6;
        avatar.y  += avatar.vy;
        avatar.x  += speed*.2;
        drawFallShadow();
      }

      drawBody(avatar.x, avatar.y);
      drawHead(avatar.x, avatar.y);
      debug();                      // Debug-Overlay

      requestAnimationFrame(tick);
    }catch(e){
      lastErr = e.message || String(e);
      requestAnimationFrame(tick);
    }
  }
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
