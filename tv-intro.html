<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pixel-Marionette – Intro (b3nn3t)</title>
  <style>
    :root{ --bg:#333333; --duration:11000; }
    html,body{height:100%;margin:0;background:var(--bg);}
    body{overflow:hidden;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    canvas{
      display:block;width:100vw;height:100vh;
      image-rendering:pixelated; image-rendering:crisp-edges;
      background:var(--bg)
    }
    #main{position:fixed;inset:0;display:grid;place-items:center;background:#111;color:#fff;opacity:0;pointer-events:none;transition:opacity .8s ease}
    #main.show{opacity:1;pointer-events:auto}
    #main .card{max-width:min(90vw,840px);padding:32px;border-radius:16px;background:#181818;box-shadow:0 10px 40px rgba(0,0,0,.45)}
  </style>
</head>
<body>
  <canvas id="stage"></canvas>
  <section id="main" aria-hidden="true">
    <div class="card"><h1>Willkommen!</h1><p>Platzhalter für die Hauptseite.</p></div>
  </section>

  <script>
  // ======= KNOBS =======
  const HEAD_IMG_URL = location.origin + "/img/dein-pixel-kopf.webp?v=" + Date.now(); // oder png
  const RUN_TO_RIGHT = true;             // links -> rechts
  const CHROMA_TOLERANCE = 40;           // 25–45: falls graue Reste sichtbar
  const TRAIL_TEXT = "b3nn3t";           // Buchstabenfolge
  const TRAIL_SPAWN_MS = 300;            // Abstand zwischen neuen Buchstaben
  // =====================

  const canvas = document.getElementById('stage');
  const ctx = canvas.getContext('2d'); // ohne Options-Objekt (maximale Kompatibilität)

  // Fail-safe: wenn es je einen Fehler gibt, wird er oben links angezeigt
  let lastError = "";
  window.addEventListener('error', e => { lastError = (e && e.message) ? e.message : String(e); });
  function drawErrorOverlay(){
    if(!lastError) return;
    ctx.save();
    ctx.font = '14px monospace';
    const w = Math.min(canvas.width - 32, ctx.measureText(lastError).width + 16);
    ctx.fillStyle = 'rgba(255,80,80,.95)';
    ctx.fillRect(8,8,w,28);
    ctx.fillStyle = '#000';
    ctx.fillText(lastError, 16, 28);
    ctx.restore();
  }

  let W=0, H=0, DPR=1;
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
  function PX(){ return Math.max(2, Math.floor(Math.min(W,H) / 240)); }
  const lineY   = () => Math.floor(H * 2/3);
  const lineEndX= () => Math.floor(W * 0.82);

  function resize(){
    try{
      DPR = Math.max(1, Math.floor(window.devicePixelRatio||1));
      W = canvas.width  = clamp(Math.floor(innerWidth * DPR), 64, 32768);
      H = canvas.height = clamp(Math.floor(innerHeight * DPR), 64, 32768);
      canvas.style.width  = innerWidth + 'px';
      canvas.style.height = innerHeight + 'px';
      if (ctx) ctx.imageSmoothingEnabled = false;
      // nach Resize: Wort neu zentrieren
      baseX = null;
    }catch(e){ lastError = e.message || String(e); }
  }
  window.addEventListener('resize', resize); resize();

  const avatar = {
    state:'walk',
    x: RUN_TO_RIGHT ? -40*PX() : W+40*PX(),
    y: lineY() - 3*PX(),         // Füße auf der Linie (3*PX Stiefel)
    vx: RUN_TO_RIGHT ? 2.1 : -2.1,
    vy:0, gravity:.35, step:0,
    headScale:22, bodyScale:12
  };

  // Kopf-Hintergrund entfernen (Chroma-Key) – nicht-blockierend
  function removeGrayBG(image, tolerance = CHROMA_TOLERANCE) {
    try{
      const off = document.createElement("canvas");
      off.width = image.width; off.height = image.height;
      const octx = off.getContext("2d");
      octx.imageSmoothingEnabled = false;
      octx.drawImage(image, 0, 0);
      const imgData = octx.getImageData(0, 0, off.width, off.height);
      const d = imgData.data;
      const keyR = d[0], keyG = d[1], keyB = d[2]; // Ecke (0,0)
      for (let i = 0; i < d.length; i += 4) {
        const dr=Math.abs(d[i]-keyR), dg=Math.abs(d[i+1]-keyG), db=Math.abs(d[i+2]-keyB);
        if (dr < tolerance && dg < tolerance && db < tolerance) d[i+3] = 0; // transparent
      }
      octx.putImageData(imgData, 0, 0);
      return off;
    }catch(e){
      // Wenn irgendwas schiefgeht, gib einfach das Original zurück (kein Blocker)
      console.warn("Chroma-Key skipped:", e);
      return image;
    }
  }

  // Kopf laden (blockiert nie die Animation)
  let headReady = false;
  let headImg = null;
  (function loadHead(){
    try{
      const img = new Image();
      img.crossOrigin='anonymous'; // same-origin ok
      img.onload = () => { try{ headImg = removeGrayBG(img); headReady = true; }catch(e){ headImg = img; headReady = true; } };
      img.onerror = (e) => { console.warn('HEAD ERROR', HEAD_IMG_URL, e); headReady = false; headImg = null; };
      img.src = HEAD_IMG_URL;
    }catch(e){ console.warn("HEAD load failed", e); }
  })();

  function drawLine(){
    ctx.strokeStyle='#fff';
    ctx.lineWidth = 2*PX();
    ctx.beginPath(); ctx.moveTo(0, lineY()); ctx.lineTo(lineEndX(), lineY()); ctx.stroke();
  }

  function rect(px,py,w,h,fill){
    ctx.fillStyle=fill; ctx.fillRect(px,py,w,h);
    ctx.fillStyle='#000';
    ctx.fillRect(px-1,py,w+2,1);
    ctx.fillRect(px-1,py+h-1,w+2,1);
    ctx.fillRect(px-1,py,1,h);
    ctx.fillRect(px+w-1,py,1,h);
  }

  function drawBody(x,y){
    const p=PX(), bodyH=avatar.bodyScale*p, bodyW=Math.round(8*p);
    const legLen=Math.round(9*p), armLen=Math.round(7*p);

    const torsoX=Math.round(x-bodyW/2), torsoY=Math.round(y-bodyH);
    rect(torsoX,torsoY,bodyW,bodyH,'#2b3a56');

    function limb(px,py,len,phase,thk,col){
      const swing = Math.round(Math.sin(phase)*1*p);
      rect(px, py+swing, thk, len, col);
    }
    const armTh=3*p, legTh=4*p;
    limb(Math.round(x+3*p), torsoY+Math.round(3*p), armLen, avatar.step,          armTh, '#2b3a56');
    limb(Math.round(x-6*p), torsoY+Math.round(3*p), armLen, avatar.step+Math.PI,  armTh, '#2b3a56');

    limb(Math.round(x+1*p), y - legLen, legLen, avatar.step,         legTh, '#233047');
    limb(Math.round(x-3*p), y - legLen, legLen, avatar.step+Math.PI, legTh, '#233047');

    rect(Math.round(x+1*p), Math.round(lineY()-3*p), 6*p, 3*p, '#7a4f1f');
    rect(Math.round(x-3*p), Math.round(lineY()-3*p), 6*p, 3*p, '#7a4f1f');
  }

  function drawHead(x,y){
    const p = PX();
    const s = avatar.headScale * p; const w=s, h=s;
    const top = y - avatar.bodyScale * p - s - 2*p;

    if (headReady && headImg && headImg.width){
      ctx.drawImage(headImg, Math.round(x - w/2), Math.round(top), Math.round(w), Math.round(h));
    } else {
      // Platzhalter (damit NIE „nur grau“ erscheint)
      ctx.fillStyle='#c9a23b'; ctx.fillRect(Math.round(x - w/2), Math.round(top), Math.round(w), Math.round(h*.62));
      ctx.fillStyle='#f2b59a'; ctx.fillRect(Math.round(x - w/2), Math.round(top + h*.45), Math.round(w), Math.round(h*.45));
    }
  }

  function letterYOnHead(){
    const p = PX();
    const s = avatar.headScale * p;
    return avatar.y - avatar.bodyScale*p - s/2;
  }

  const letters = []; // {ch, x, y}
  let nextSpawnAt = performance.now() + TRAIL_SPAWN_MS;
  let spawnIndex = 0;

  function spawnNextLetter(){
    const p = PX(); const ch = TRAIL_TEXT[spawnIndex];
    letters.push({ch, x: avatar.x - 12*p, y: letterYOnHead()});
    spawnIndex++;
  }

  function updateLetters(){
    const p = PX();
    const spacing = 12*p;
    const targetY = letterYOnHead();
    for(let i=0;i<letters.length;i++){
      const targetX = avatar.x - spacing * (letters.length - i);
      letters[i].x += (targetX - letters[i].x) * 0.15;
      letters[i].y += (targetY - letters[i].y) * 0.15;
    }
  }

  function drawLetters(){
    const p = PX();
    ctx.font = (12*p) + 'px monospace';
    ctx.textBaseline = 'middle';
    for(const L of letters){
      ctx.lineWidth = 2*p; ctx.strokeStyle = '#000';
      ctx.strokeText(L.ch, Math.round(L.x), Math.round(L.y));
      ctx.fillStyle = '#f2f2f2';
      ctx.fillText(L.ch, Math.round(L.x), Math.round(L.y));
    }
  }

  let baseX=null; // (nicht gebraucht hier, aber vom Resize genutzt)
  let raf;
  function tick(){
    try{
      ctx.clearRect(0,0,W,H);
      drawLine();

      const now = performance.now();
      const p=PX(), speed=avatar.vx*p;

      if(spawnIndex < TRAIL_TEXT.length && now >= nextSpawnAt){
        spawnNextLetter(); nextSpawnAt = now + TRAIL_SPAWN_MS;
      }
      updateLetters();
      drawLetters();

      if(avatar.state==='walk'){
        avatar.x += speed; avatar.step += .15;
        avatar.y = lineY() - 3*p + Math.round(Math.sin(avatar.step*2) * 0.5*p);
        const atEdge = RUN_TO_RIGHT ? (avatar.x >= lineEndX()-6*p) : (avatar.x <= lineEndX()+6*p);
