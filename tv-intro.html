<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pixel-Marionette – Intro (b3nn3t hammern)</title>
  <style>
    :root{ --bg:#333333; --duration:11000; }
    html,body{height:100%;margin:0;background:var(--bg);}
    body{overflow:hidden;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    canvas{
      display:block;width:100vw;height:100vh;
      image-rendering:pixelated; image-rendering:crisp-edges;
      background:var(--bg)
    }
    #main{position:fixed;inset:0;display:grid;place-items:center;background:#111;color:#fff;opacity:0;pointer-events:none;transition:opacity .8s ease}
    #main.show{opacity:1;pointer-events:auto}
    #main .card{max-width:min(90vw,840px);padding:32px;border-radius:16px;background:#181818;box-shadow:0 10px 40px rgba(0,0,0,.45)}
  </style>
</head>
<body>
  <canvas id="stage"></canvas>
  <section id="main" aria-hidden="true">
    <div class="card"><h1>Willkommen!</h1><p>Platzhalter für die Hauptseite.</p></div>
  </section>

  <script>
  // ======= KNOBS =======
  const HEAD_IMG_URL      = location.origin + "/img/dein-pixel-kopf.webp?v=" + Date.now();
  const RUN_TO_RIGHT      = true;           // links -> rechts
  const CHROMA_TOLERANCE  = 40;             // 25–45: falls graue Reste sichtbar
  const HEAD_Y_OFFSET_PX  = 3;              // Kopf etwas tiefer (PX()-Einheiten)
  const WORD              = "b3nn3t";       // zu hämmerndes Wort
  const LETTER_GAP_PX     = 14;             // Abstand zw. Buchstaben (PX()-Einheiten)
  const LIFT_MS           = 600;            // langsames Hochhämmern (Aufwärts-Animation)
  const HAMMER_MS         = 420;            // Dauer des Schlagzyklus (down+up)
  // =====================

  const canvas = document.getElementById('stage');
  const ctx = canvas.getContext('2d');

  let W, H, DPR;
  function resize(){
    DPR = Math.max(1, Math.floor(window.devicePixelRatio||1));
    W = canvas.width  = Math.floor(innerWidth * DPR);
    H = canvas.height = Math.floor(innerHeight * DPR);
    canvas.style.width  = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    ctx.imageSmoothingEnabled = false;
    // bei Resize die mittige Platzierung neu berechnen
    baseX = null;
  }
  window.addEventListener('resize', resize); resize();

  const lineY   = () => Math.floor(H * 2/3);
  const lineEndX= () => Math.floor(W * 0.82);
  const PX      = () => Math.max(2, Math.floor(Math.min(W,H) / 240));

  const avatar = {
    state:'walk',
    x: RUN_TO_RIGHT ? -40*PX() : W+40*PX(),
    // Füße auf Linie: Basis-y = Linie - Stiefelhöhe (3*PX)
    y: lineY() - 3*PX(),
    vx: RUN_TO_RIGHT ? 2.1 : -2.1,
    vy:0, gravity:.35, step:0,
    headScale:22, bodyScale:12,
    hammerUntil: 0,                   // Zeit bis wann die Schlag-Animation aktiv ist
    hammerLetterIndex: -1             // welcher Buchstabe gerade gehämmert wird
  };

  // Kopf-Chroma-Key
  function removeGrayBG(image, tolerance = CHROMA_TOLERANCE) {
    const off = document.createElement("canvas");
    off.width = image.width; off.height = image.height;
    const octx = off.getContext("2d", { willReadFrequently: true });
    octx.imageSmoothingEnabled = false;
    octx.drawImage(image, 0, 0);
    const imgData = octx.getImageData(0, 0, off.width, off.height);
    const d = imgData.data;
    const keyR = d[0], keyG = d[1], keyB = d[2];
    for (let i = 0; i < d.length; i += 4) {
      const dr=Math.abs(d[i]-keyR), dg=Math.abs(d[i+1]-keyG), db=Math.abs(d[i+2]-keyB);
      if (dr < tolerance && dg < tolerance && db < tolerance) d[i+3] = 0;
    }
    octx.putImageData(imgData, 0, 0);
    return off;
  }

  let headReady = false;
  let headImg = new Image(); headImg.crossOrigin='anonymous';
  headImg.onload  = () => { headImg = removeGrayBG(headImg); headReady = true; };
  headImg.onerror = (e)  => { console.error('HEAD ERROR', HEAD_IMG_URL, e); };
  headImg.src = HEAD_IMG_URL;

  // Linie
  function drawLine(){
    ctx.strokeStyle='#fff';
    ctx.lineWidth = 2*PX();
    ctx.beginPath(); ctx.moveTo(0, lineY()); ctx.lineTo(lineEndX(), lineY()); ctx.stroke();
  }

  // Pixelrechteck + Outline
  function rect(px,py,w,h,fill){
    ctx.fillStyle=fill; ctx.fillRect(px,py,w,h);
    ctx.fillStyle='#000';
    ctx.fillRect(px-1,py,w+2,1);
    ctx.fillRect(px-1,py+h-1,w+2,1);
    ctx.fillRect(px-1,py,1,h);
    ctx.fillRect(px+w-1,py,1,h);
  }

  // flacher 2D-Körper (seitlich), ohne Fäden
  function drawBody(x,y){
    const p=PX(), bodyH=avatar.bodyScale*p, bodyW=Math.round(8*p);
    const legLen=Math.round(9*p), armLen=Math.round(7*p);

    // Torso
    const torsoX=Math.round(x-bodyW/2), torsoY=Math.round(y-bodyH);
    rect(torsoX,torsoY,bodyW,bodyH,'#2b3a56');

    // 2D-Arme/Beine (seitlich). Wenn hammern → rechter Arm oben/unten schnellen.
    const armTh=3*p, legTh=4*p;
    const hammering = performance.now() < avatar.hammerUntil;

    const armSwing = hammering
      ? (Math.sin((1 - (avatar.hammerUntil - performance.now())/HAMMER_MS) * Math.PI) * -2*p)
      : Math.sin(avatar.step) * 1*p;

    // Vorder-/Hinterarm
    rect(Math.round(x+3*p), torsoY+Math.round(3*p)+Math.round(armSwing), armTh, Math.round(7*p), '#2b3a56');
    rect(Math.round(x-6*p), torsoY+Math.round(3*p)-Math.round(armSwing), armTh, Math.round(7*p), '#2b3a56');

    // Beine: kleine Schrittbewegung, beim Fallen losgelöst von der Linie
    const legSwing = Math.sin(avatar.step)*1*p;
    const legBaseY = (avatar.state==='fall') ? y : y; // Start oben, Stiefel separat
    rect(Math.round(x+1*p), legBaseY - legLen + Math.round(legSwing), legTh, legLen, '#233047'); // vorderes Bein
    rect(Math.round(x-3*p), legBaseY - legLen - Math.round(legSwing), legTh, legLen, '#233047'); // hinteres Bein

    // Stiefel
    const bootY = (avatar.state==='fall') ? Math.round(y) : Math.round(lineY()-3*p);
    rect(Math.round(x+1*p), bootY, 6*p, 3*p, '#7a4f1f');
    rect(Math.round(x-3*p), bootY, 6*p, 3*p, '#7a4f1f');

    // Pixel-Hammer (einfaches Sprite) – erscheint beim Schlag neben rechter Hand
    if (hammering && avatar.hammerLetterIndex >= 0) {
      const phase = 1 - (avatar.hammerUntil - performance.now())/HAMMER_MS; // 0..1
      const hx = Math.round(x + 7*p);
      const hyBase = Math.round(torsoY + 2*p);
      const hy = hyBase + Math.round(Math.sin(phase*Math.PI) * 6*p); // up/down
      // Holzstiel
      ctx.fillStyle = '#7a4f1f';
      ctx.fillRect(hx, hy, 1*p, 8*p);
      // Hammerkopf
      ctx.fillStyle = '#c0c0c0';
      ctx.fillRect(hx-3*p, hy, 7*p, 2*p);
      ctx.fillStyle = '#000'; // Outline
      ctx.fillRect(hx-3*p-1, hy, 1, 2*p);
      ctx.fillRect(hx+7*p-1, hy, 1, 2*p);
      ctx.fillRect(hx-3*p-1, hy-1, 7*p+2, 1);
      ctx.fillRect(hx-3*p-1, hy+2*p-1, 7*p+2, 1);
    }
  }

  // Kopf (etwas tiefer)
  function drawHead(x,y){
    const p = PX();
    const s = avatar.headScale * p; const w=s, h=s;
    const top = y - avatar.bodyScale * p - s - 2*p + HEAD_Y_OFFSET_PX*p;

    if (headReady && headImg && headImg.width){
      ctx.drawImage(headImg, Math.round(x - w/2), Math.round(top), Math.round(w), Math.round(h));
    } else {
      ctx.fillStyle='#c9a23b'; ctx.fillRect(Math.round(x - w/2), Math.round(top), Math.round(w), Math.round(h*.62));
      ctx.fillStyle='#f2b59a'; ctx.fillRect(Math.round(x - w/2), Math.round(top + h*.45), Math.round(w), Math.round(h*.45));
    }
  }

  // y-Position der Buchstaben: eine Zeile über dem Kopf
  function letterYAboveHead(){
    const p = PX();
    const s = avatar.headScale * p;
    return avatar.y - avatar.bodyScale*p - s - 6*p + HEAD_Y_OFFSET_PX*p;
  }

  // --- Buchstaben: mittig platzieren, langsam hochhämmern & stehen lassen ---
  let baseX = null;                    // Mitte für das Wort
  const letters = [];                  // {ch, idx, x, y, finalY, t0, hammered}
  let nextIndexToHammer = 0;

  function ensureBaseX(){
    if (baseX !== null) return;
    const p = PX(), spacing = LETTER_GAP_PX*p;
    const totalWidth = (WORD.length-1)*spacing;
    baseX = Math.round(W/2 - totalWidth/2);
  }

  function targetXForIndex(i){
    const p = PX(), spacing = LETTER_GAP_PX*p;
    ensureBaseX();
    return baseX + i*spacing;
  }

  function maybeHammerNext(){
    if (nextIndexToHammer >= WORD.length) return;
    const idx = nextIndexToHammer;
    const tx = targetXForIndex(idx);

    // Schlag, wenn Avatar auf Höhe des Ziel-X ist
    if ( (RUN_TO_RIGHT && avatar.x >= tx) || (!RUN_TO_RIGHT && avatar.x <= tx) ) {
      const p = PX();
      const finalY = letterYAboveHead();
      const L = {
        ch: WORD[idx], idx, x: tx,
        y: finalY + 10*p,           // startet etwas tiefer
        finalY, t0: performance.now(),
        hammered: false
      };
      letters.push(L);

      avatar.hammerUntil = performance.now() + HAMMER_MS;
      avatar.hammerLetterIndex = idx;

      nextIndexToHammer++;
    }
  }

  function updateLetters(){
    const now = performance.now();
    for (const L of letters){
      if (!L.hammered){
        const t = Math.min(1, (now - L.t0) / LIFT_MS);   // 0..1
        // EaseOutCubic
        const e = 1 - Math.pow(1-t, 3);
        L.y = Math.round(L.finalY + (L.finalY + 0 - L.y) * 0 + (0) ); // stabil
        L.y = Math.round(L.finalY + ( (L.finalY + 0) - (L.finalY + 10*PX()) ) * e ); // sanft von unten nach oben
        if (t >= 1) L.hammered = true;
      }
    }
  }

  function drawLettersStatic(){
    const p = PX();
    ctx.font = (12*p) + 'px monospace';
    ctx.textBaseline = 'middle';
    for(const L of letters){
      // Outline + Füllung
      ctx.lineWidth = 2*p; ctx.strokeStyle = '#000';
      ctx.strokeText(L.ch, Math.round(L.x), Math.round(L.y));
      ctx.fillStyle = '#f2f2f2';
      ctx.fillText(L.ch, Math.round(L.x), Math.round(L.y));
    }
  }

  // --- Loop ---
  let raf;
  function tick(){
    try{
      ctx.clearRect(0,0,W,H);
      drawLine();

      const p=PX(), speed=avatar.vx*p;

      // 1) Buchstaben (liegen hinter der Figur)
      maybeHammerNext();
      updateLetters();
      drawLettersStatic();

      // 2) Avatar oben drüber
      if(avatar.state==='walk'){
        avatar.x += speed; avatar.step += .15;
        // leichtes Wippen, Füße bleiben auf Linie
        avatar.y = lineY() - 3*p + Math.round(Math.sin(avatar.step*2) * 0.4*p);
        const atEdge = RUN_TO_RIGHT ? (avatar.x >= lineEndX()-6*p) : (avatar.x <= lineEndX()+6*p);
        if(atEdge){ avatar.state='fall'; avatar.vy=0; }
      } else if(avatar.state==='fall'){
        avatar.vy += avatar.gravity*p*.6;
        avatar.y  += avatar.vy;
        avatar.x  += speed*.2;
        if(avatar.y > H + 40*p){ avatar.state='done'; startTransition(); }
      }

      drawBody(avatar.x, avatar.y);
      drawHead(avatar.x, avatar.y);
    } catch(err){ console.error('TICK ERROR', err); }
    raf = requestAnimationFrame(tick);
  }
  tick();

  // --- Übergang ---
  const main=document.getElementById('main');
  function startTransition(){
    cancelAnimationFrame(raf);
    main.classList.add('show');
    const redirectTo=null; // z.B. '/home' oder 'https://example.com/app'
    if(redirectTo){ setTimeout(()=>location.href=redirectTo,900); }
  }
  setTimeout(()=>{ if(avatar.state!=='done') startTransition(); },
    parseInt(getComputedStyle(document.documentElement).getPropertyValue('--duration')));
  </script>
</body>
</html>
