<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pixel-Marionette – Sprite (b3nn3t, Hammer + Funken)</title>
  <style>
    :root{ --bg:#333333; --duration:12000; }
    html,body{height:100%;margin:0;background:var(--bg);}
    body{overflow:hidden;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    canvas{
      display:block;width:100vw;height:100vh;
      image-rendering:pixelated; image-rendering:crisp-edges;
      background:var(--bg)
    }
    #main{position:fixed;inset:0;display:grid;place-items:center;background:#111;color:#fff;opacity:0;pointer-events:none;transition:opacity .8s ease}
    #main.show{opacity:1;pointer-events:auto}
    #main .card{max-width:min(90vw,840px);padding:32px;border-radius:16px;background:#181818;box-shadow:0 10px 40px rgba(0,0,0,.45)}
  </style>
</head>
<body>
  <canvas id="stage"></canvas>
  <section id="main" aria-hidden="true">
    <div class="card"><h1>Willkommen!</h1><p>Platzhalter für die Hauptseite.</p></div>
  </section>

  <script>
  // ================== KNOBS (anpassen) ==================
  const SPRITE_URL   = location.origin + "/img/avatar-walk.png?v=" + Date.now(); // <— DEIN Sprite-Sheet
  const FRAME_W      = 128;   // Breite eines Frames im Sprite (px)
  const FRAME_H      = 128;   // Höhe eines Frames im Sprite (px)
  const FRAMES       = 8;     // Anzahl Frames in der Zeile
  const FPS          = 10;    // Animationsgeschwindigkeit (Frames pro Sekunde)

  const RUN_TO_RIGHT     = true;          // links -> rechts
  const WORD             = "b3nn3t";      // zu hämmerndes Wort
  const LETTER_GAP_PX    = 14;            // Abstand Zwischenräumen in PX()-Einheiten
  const LIFT_MS          = 650;           // langsam hochhämmern
  const HAMMER_MS        = 420;           // Schlag-Zyklus
  const SPARK_COUNT      = 10;            // Funken pro Schlag
  // ======================================================

  const canvas = document.getElementById('stage');
  const ctx = canvas.getContext('2d');

  let W=0, H=0, DPR=1;
  function resize(){
    DPR = Math.max(1, Math.floor(window.devicePixelRatio||1));
    W = canvas.width  = Math.floor(innerWidth * DPR);
    H = canvas.height = Math.floor(innerHeight * DPR);
    canvas.style.width  = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    ctx.imageSmoothingEnabled = false;
    baseX = null;
  }
  window.addEventListener('resize', resize); resize();

  const lineY   = () => Math.floor(H * 2/3);
  const lineEndX= () => Math.floor(W * 0.82);
  const PX      = () => Math.max(2, Math.floor(Math.min(W,H) / 240)); // Pixelrastergröße

  // -------- Sprite laden --------
  let spr = new Image(); spr.crossOrigin = "anonymous";
  let sprReady = false;
  spr.onload = () => sprReady = true;
  spr.onerror = () => { sprReady = false; console.warn("Sprite nicht gefunden:", SPRITE_URL); };
  spr.src = SPRITE_URL;

  // -------- Avatar-Physik --------
  const avatar = {
    state: 'walk',
    x: RUN_TO_RIGHT ? -40*PX() : W + 40*PX(),
    vx: RUN_TO_RIGHT ? 2.1 : -2.1,
    y: lineY(),     // Wir zeichnen Sprite an den Füßen ausgerichtet
    vy: 0, gravity: 0.35,
    frame: 0, frameTime: 0,
    hammerUntil: 0,
    hammerLetterIndex: -1
  };

  // -------- Linie --------
  function drawLine(){
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2*PX();
    ctx.beginPath(); ctx.moveTo(0, lineY()); ctx.lineTo(lineEndX(), lineY()); ctx.stroke();
  }

  // -------- Sprite zeichnen (Füße auf Linie) --------
  function drawSprite(xFeet, yLine){
    if(!sprReady){ // Fallback: kleiner Platzhalter
      const p=PX();
      ctx.fillStyle='#2b3a56';
      ctx.fillRect(Math.round(xFeet-6*p), Math.round(yLine-20*p), 12*p, 20*p);
      ctx.fillStyle='#7a4f1f';
      ctx.fillRect(Math.round(xFeet-6*p), Math.round(yLine-3*p), 12*p, 3*p);
      return;
    }
    // Maßstab: Sprite soll zur Leinwand passen (skaliert im Raster)
    const p = PX();
    const targetH = 28*p;                   // ca. 28 „Pixel“ hoch (passt zum bisherigen Look)
    const scale = targetH / FRAME_H;
    const drawW = Math.round(FRAME_W * scale);
    const drawH = Math.round(FRAME_H * scale);

    // Frame auswählen
    const sx = (avatar.frame|0) % FRAMES * FRAME_W;
    const sy = 0;

    // Füße auf Linie ausrichten -> unten mittig
    const dx = Math.round(xFeet - drawW/2);
    const dy = Math.round(yLine - drawH);

    // Schlag: minimalen „Kopfstoß“ simulieren (Y-Wackler)
    const hammering = performance.now() < avatar.hammerUntil;
    const phase = Math.max(0, 1 - (avatar.hammerUntil - performance.now())/HAMMER_MS);
    const wobbleY = hammering ? Math.round(Math.sin(phase*Math.PI)*2) : 0;

    ctx.drawImage(spr, sx, sy, FRAME_W, FRAME_H, dx, dy + wobbleY, drawW, drawH);

    // Hammer (einfaches Pixel-Sprite) neben rechter Hand, nur beim Schlag
    if (hammering && avatar.hammerLetterIndex >= 0){
      const hx = Math.round(xFeet + 8*p);
      const hy = Math.round(dy + 10*p + Math.sin(phase*Math.PI)*6*p);
      // Stiel
      ctx.fillStyle = '#7a4f1f'; ctx.fillRect(hx, hy, 1*p, 8*p);
      // Kopf
      ctx.fillStyle = '#c0c0c0'; ctx.fillRect(hx-3*p, hy, 7*p, 2*p);
      ctx.fillStyle = '#000';
      ctx.fillRect(hx-3*p-1, hy, 1, 2*p);
      ctx.fillRect(hx+7*p-1, hy, 1, 2*p);
      ctx.fillRect(hx-3*p-1, hy-1, 7*p+2, 1);
      ctx.fillRect(hx-3*p-1, hy+2*p-1, 7*p+2, 1);
    }
  }

  // -------- Wort „b3nn3t“ mittig, hochhämmern, stehen lassen --------
  let baseX = null;
  const letters = []; // {ch, idx, x, y, startY, finalY, t0, hammered}
  let nextIndexToHammer = 0;

  function letterYAboveHead(){
    // Beim Sprite nehmen wir grob 18p über der Linie (überm Kopf)
    return lineY() - 18*PX();
  }
  function ensureBaseX(){
    if (baseX !== null) return;
    const p = PX(), spacing = LETTER_GAP_PX*p;
    const totalWidth = (WORD.length-1)*spacing;
    baseX = Math.round(W/2 - totalWidth/2);
  }
  function targetXForIndex(i){
    const p = PX(), spacing = LETTER_GAP_PX*p;
    ensureBaseX();
    return baseX + i*spacing;
  }

  // Funken/Staub
  const sparks = []; // {x,y,vx,vy,life,born,alpha}
  function spawnSparks(x,y){
    const p = PX();
    for(let i=0;i<10;i++){
      const ang = Math.random()*Math.PI - Math.PI/2;
      const spd = (0.8 + Math.random()*0.8) * 6*p;
      sparks.push({
        x, y,
        vx: Math.cos(ang)*spd,
        vy: Math.sin(ang)*spd - 1*p,
        life: 450 + Math.random()*250,
        born: performance.now(),
        alpha: 1
      });
    }
  }
  function updateSparks(){
    const now = performance.now(), p = PX();
    for(let i=sparks.length-1;i>=0;i--){
      const s = sparks[i];
      const t = now - s.born;
      if (t > s.life){ sparks.splice(i,1); continue; }
      s.vy += 0.02 * p;
      s.x  += s.vx * 0.016;
      s.y  += s.vy * 0.016;
      s.alpha = 1 - (t / s.life);
    }
  }
  function drawSparks(){
    const p = PX();
    for(const s of sparks){
      ctx.globalAlpha = Math.max(0, Math.min(1, s.alpha));
      ctx.fillStyle = '#ffd966';
      ctx.fillRect(Math.round(s.x/p)*p, Math.round(s.y/p)*p, 2*p, 2*p);
    }
    ctx.globalAlpha = 1;
  }

  function maybeHammerNext(){
    if (nextIndexToHammer >= WORD.length) return;
    const idx = nextIndexToHammer;
    const tx = targetXForIndex(idx);

    if ((RUN_TO_RIGHT && avatar.x >= tx) || (!RUN_TO_RIGHT && avatar.x <= tx)) {
      const p = PX();
      const finalY = letterYAboveHead();
      const L = {
        ch: WORD[idx], idx, x: tx,
        startY: finalY + 10*p, y: finalY + 10*p,
        finalY, t0: performance.now(),
        hammered: false
      };
      letters.push(L);

      avatar.hammerUntil = performance.now() + HAMMER_MS;
      avatar.hammerLetterIndex = idx;
      spawnSparks(tx, finalY);

      nextIndexToHammer++;
    }
  }
  function updateLetters(){
    const now = performance.now();
    for (const L of letters){
      if (!L.hammered){
        const t = Math.min(1, (now - L.t0) / LIFT_MS);
        const e = 1 - Math.pow(1-t, 3);      // easeOutCubic
        L.y = Math.round(L.startY + (L.finalY - L.startY) * e);
        if (t >= 1) L.hammered = true;
      }
    }
  }
  function drawLetters(){
    const p = PX();
    ctx.font = (12*p) + 'px monospace';
    ctx.textBaseline = 'middle';
    for(const L of letters){
      ctx.lineWidth = 2*p; ctx.strokeStyle = '#000';
      ctx.strokeText(L.ch, Math.round(L.x), Math.round(L.y));
      ctx.fillStyle = '#f2f2f2';
      ctx.fillText(L.ch, Math.round(L.x), Math.round(L.y));
    }
  }

  // -------- Loop --------
  let lastTS = performance.now();
  function tick(nowTS){
    const dt = Math.min(100, nowTS - lastTS); lastTS = nowTS;

    ctx.clearRect(0,0,W,H);
    drawLine();

    // Buchstaben (hinter der Figur)
    maybeHammerNext();
    updateLetters();
    updateSparks();
    drawLetters();
    drawSparks();

    // Avatar-Bewegung
    const p = PX(), speed = avatar.vx * p;
    if (avatar.state === 'walk') {
      avatar.x += speed;
      // Sprite-Animation
      avatar.frameTime += dt;
      const msPerFrame = 1000 / FPS;
      while (avatar.frameTime > msPerFrame){
        avatar.frameTime -= msPerFrame;
        avatar.frame = (avatar.frame + 1) % FRAMES;
      }
      // Sturztrigger am rechten Rand (weiße Linie endet)
      const atEdge = RUN_TO_RIGHT ? (avatar.x >= lineEndX()-6*p) : (avatar.x <= lineEndX()+6*p);
      if (atEdge) { avatar.state = 'fall'; avatar.vy = 0; }
    } else if (avatar.state === 'fall') {
      avatar.vy += avatar.gravity * p * 0.6;
      avatar.y  += avatar.vy;
      avatar.x  += speed * 0.2;
      // beim Fallen keine Linienbindung mehr: Füße lösen sich mit
      if (avatar.y > H + 40*p) { avatar.state = 'done'; startTransition(); }
    }

    drawSprite(avatar.x, avatar.y);

    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // -------- Übergang --------
  const main = document.getElementById('main');
  function startTransition(){
    main.classList.add('show');
    const redirectTo = null; // z.B. '/home' oder 'https://example.com'
    if (redirectTo) setTimeout(()=>location.href=redirectTo, 900);
  }
  setTimeout(()=>{ if(avatar.state!=='done') startTransition(); },
    parseInt(getComputedStyle(document.documentElement).getPropertyValue('--duration')));
  </script>
</body>
</html>
