<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pixel-Marionette – Intro</title>
  <style>
    :root{
      --bg:#1e1e1e;
      --line:#ffffff;
      --duration:11000; /* Gesamtdauer (ms) bis zur Übergabe an Hauptseite */
    }
    html,body{height:100%;margin:0;background:var(--bg);}
    body{overflow:hidden;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    /* Pixel-Look */
    canvas{display:block;width:100vw;height:100vh;image-rendering: pixelated;image-rendering: crisp-edges;background:var(--bg)}

    /* Hauptinhalt (wird nach dem Intro eingeblendet) */
    #main{position:fixed;inset:0;display:grid;place-items:center;background:#111;color:#fff;opacity:0;pointer-events:none;transition:opacity .8s ease}
    #main.show{opacity:1;pointer-events:auto}
    #main .card{max-width:min(90vw,840px);padding:32px;border-radius:16px;background:#181818;box-shadow:0 10px 40px rgba(0,0,0,.45)}
  </style>
</head>
<body>
  <!-- Intro-Canvas -->
  <canvas id="stage"></canvas>

  <!-- Beispiel-Hauptseite (ersetzt später eure echte Seite) -->
  <section id="main" aria-hidden="true">
    <div class="card">
      <h1>Willkommen!</h1>
      <p>Dies ist der Platzhalter für die Hauptseite. Das Intro blendet automatisch hierhin über.</p>
      <p><small>Tipp: Um auf eine andere URL zu navigieren, sucht im Script nach <code>redirectTo</code> und setzt eure Ziel-URL.</small></p>
    </div>
  </section>

  <script>
    /**
     * PIXEL-MARIONETTE INTRO (SEGA/Nintendo inspiriert)
     * -------------------------------------------------
     * - Figur läuft auf weißer Linie (2/3 Höhe) von LINKS nach RECHTS
     * - Kopf immer zum Betrachter, großer Kopf / kleiner Körper
     * - Am rechten Linienende fällt sie herunter und verschwindet unten
     * - Danach Übergang (Fade) zur Hauptseite oder Redirect
     */

    // === KONFIG ===
    const HEAD_IMG_URL = "img/pixel-head.png"; // Pfad ist relativ zur HTML

    const canvas = document.getElementById('stage');
    const ctx = canvas.getContext('2d');
    let W, H, DPR;

    function resize(){
      DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
      W = canvas.width = Math.floor(window.innerWidth * DPR);
      H = canvas.height = Math.floor(window.innerHeight * DPR);
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      ctx.imageSmoothingEnabled = false;
    }
    window.addEventListener('resize', resize); resize();

    // Szene
    const lineY = () => Math.floor(H * 2/3);       // Linie auf 2/3 Höhe
    const lineEndX = () => Math.floor(W * 0.82);   // RECHTES Ende, wo die Figur fällt

    // Charakter-Parameter (Pixel-Einheiten im Retro-Raster)
    const PX = () => Math.max(2, Math.floor(Math.min(W,H) / 240)); // Basis-Pixelgröße

    const avatar = {
      state: 'walk', // 'walk' | 'fall' | 'done'
      x: -40*PX(),            // Start links außerhalb des Bildes
      y: lineY() - 16*PX(),
      vx: 2.1,                // nach rechts
      vy: 0,
      gravity: 0.35,
      step: 0,
      headScale: 22, // Kopfgröße in PX()-Einheiten
      bodyScale: 12, // Körper-Höhe in PX()-Einheiten
    };

    // Kopf-Asset (mit sauberem Preload & Fehler-Logging)
    let headReady = false;
    const headImg = new Image();
    if(HEAD_IMG_URL){
      headImg.onload = () => { headReady = true; };
      headImg.onerror = (e) => { console.warn('Kopfbild konnte nicht geladen werden:', HEAD_IMG_URL, e); };
      headImg.src = HEAD_IMG_URL;
    }

    function drawLine(){
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 2*PX();
      ctx.beginPath();
      ctx.moveTo(0, lineY());         // Linie beginnt links
      ctx.lineTo(lineEndX(), lineY()); // und endet rechts (Fallkante)
      ctx.stroke();
    }

    // Einfacher Pixelkörper
    function drawBody(x,y){
      const p = PX();
      const scale = p;
      const bodyH = avatar.bodyScale * scale; // Rumpf-Höhe
      const bodyW = Math.round(8*scale);
      const legLen = Math.round(9*scale);
      const armLen = Math.round(7*scale);

      // Laufphase (0..1)
      const t = (Math.sin(avatar.step) + 1) / 2;

      // Beine
      const legSwing = 0.8; // max Winkel
      const a1 = -legSwing + t*2*legSwing;   // vorderes Bein
      const a2 = legSwing - t*2*legSwing;    // hinteres Bein

      // Pixelrechteck mit Outline
      function rect(px,py,w,h,fill){
        ctx.fillStyle = fill; ctx.fillRect(px,py,w,h);
        ctx.fillStyle = '#000';
        ctx.fillRect(px-1,py,w+2,1);
        ctx.fillRect(px-1,py+h-1,w+2,1);
        ctx.fillRect(px-1,py,1,h);
        ctx.fillRect(px+w-1,py,1,h);
      }

      // Koordinaten
      const torsoX = Math.round(x - bodyW/2);
      const torsoY = Math.round(y - bodyH);

      // Rumpf
      rect(torsoX, torsoY, bodyW, bodyH, '#2b3a56');

      // Arme (einfach schwingend)
      const armSwing = 0.7;
      const armFront = armSwing - t*2*armSwing;
      const armBack  = -armSwing + t*2*armSwing;

      function limb(px,py,len,angle,thick,color){
        const dx = Math.cos(angle)*len;
        const dy = Math.sin(angle)*len;
        rect(Math.round(px), Math.round(py), Math.max(3*scale,thick), Math.max(3*scale,thick), color);
        rect(Math.round(px+dx), Math.round(py+dy), Math.max(3*scale,thick), Math.max(3*scale,thick), color);
      }

      // Schultern
      const shoulderY = torsoY + Math.round(3*scale);
      const shoulderL = x - Math.round(6*scale);
      const shoulderR = x + Math.round(3*scale);

      limb(shoulderR, shoulderY, armLen, armFront, 3*scale, '#2b3a56'); // Vorderarm
      limb(shoulderL, shoulderY, armLen, armBack,  3*scale, '#2b3a56'); // Hinterarm

      // Beine
      const hipY = y;
      const hipL = x - Math.round(3*scale);
      const hipR = x + Math.round(1*scale);

      limb(hipR, hipY, legLen, a1, 4*scale, '#233047'); // Vorderbein
      limb(hipL, hipY, legLen, a2, 4*scale, '#233047'); // Hinterbein

      // Stiefel
      rect(Math.round(hipR + Math.cos(a1)*legLen), Math.round(hipY + Math.sin(a1)*legLen), 6*scale, 3*scale, '#7a4f1f');
      rect(Math.round(hipL + Math.cos(a2)*legLen), Math.round(hipY + Math.sin(a2)*legLen), 6*scale, 3*scale, '#7a4f1f');

      // Marionetten-Fäden (Kopf + Handgelenke)
      ctx.strokeStyle = '#bbbbbb';
      ctx.lineWidth = 1*scale;
      ctx.beginPath();
      ctx.moveTo(x, torsoY -  avatar.headScale*scale - 2*scale); ctx.lineTo(x, 0); // Kopf
      ctx.moveTo(shoulderR + Math.cos(armFront)*armLen, shoulderY + Math.sin(armFront)*armLen); ctx.lineTo(shoulderR, 0);
      ctx.moveTo(shoulderL + Math.cos(armBack )*armLen, shoulderY + Math.sin(armBack )*armLen); ctx.lineTo(shoulderL, 0);
      ctx.stroke();
    }

    function drawHead(x,y){
      const p = PX();
      const s = avatar.headScale * p;
      const top = y - avatar.bodyScale * p - s - 2*p; // über dem Rumpf

      if (headReady){
        const w = s, h = s; // quadratischer Kopf
        ctx.drawImage(headImg, Math.round(x - w/2), Math.round(top), Math.round(w), Math.round(h));
        // schwarze Outline
        ctx.fillStyle = '#000';
        ctx.fillRect(Math.round(x - w/2) - 1, Math.round(top), 1, Math.round(h));
        ctx.fillRect(Math.round(x + w/2), Math.round(top), 1, Math.round(h));
        ctx.fillRect(Math.round(x - w/2) - 1, Math.round(top) - 1, Math.round(w) + 2, 1);
        ctx.fillRect(Math.round(x - w/2) - 1, Math.round(top + h), Math.round(w) + 2, 1);
      } else {
        // Platzhalter-Kopf (falls Asset noch lädt)
        const w = s, h = s;
        ctx.fillStyle = '#c9a23b';
        ctx.fillRect(Math.round(x - w/2), Math.round(top), Math.round(w), Math.round(h*0.62));
        ctx.fillStyle = '#f2b59a';
        ctx.fillRect(Math.round(x - w/2), Math.round(top + h*0.45), Math.round(w), Math.round(h*0.45));
        ctx.fillStyle = '#000';
        ctx.fillRect(Math.round(x - w/2) - 1, Math.round(top), 1, Math.round(h));
        ctx.fillRect(Math.round(x + w/2), Math.round(top), 1, Math.round(h));
        ctx.fillRect(Math.round(x - w/2) - 1, Math.round(top) - 1, Math.round(w) + 2, 1);
        ctx.fillRect(Math.round(x - w/2) - 1, Math.round(top + h), Math.round(w) + 2, 1);
      }
    }

    // Animation
    let raf;
    function tick(){
      ctx.clearRect(0,0,W,H);
      drawLine();

      const p = PX();
      const speed = avatar.vx * p; // DPI- und Größe-sensitiv

      if(avatar.state === 'walk'){
        avatar.x += speed;          // → nach rechts
        avatar.step += 0.15;        // Schrittfrequenz
        avatar.y = lineY() - 2*p + Math.round(Math.sin(avatar.step*2) * 1*p);
        if(avatar.x >= lineEndX() - 6*p){
          avatar.state = 'fall';
          avatar.vy = 0; // Startfall
        }
      } else if(avatar.state === 'fall'){
        avatar.vy += avatar.gravity * p * 0.6;
        avatar.y += avatar.vy;
        avatar.x += speed * 0.2; // leichter Drift nach rechts
        if(avatar.y > H + 40*p){
          avatar.state = 'done';
          startTransition();
        }
      }

      // Zeichnen
      drawBody(avatar.x, avatar.y);
      drawHead(avatar.x, avatar.y);

      raf = requestAnimationFrame(tick);
    }

    // Übergang zur Hauptseite
    const main = document.getElementById('main');
    function startTransition(){
      cancelAnimationFrame(raf);
      main.classList.add('show');
      const redirectTo = null; // z.B. '/home' oder 'https://example.com/app'
      if(redirectTo){ setTimeout(()=>{ window.location.href = redirectTo; }, 900); }
    }

    // Starten (Fallback: automatische Beendigung nach fester Dauer)
    tick();
    setTimeout(()=>{ if(avatar.state!=='done') startTransition(); }, parseInt(getComputedStyle(document.documentElement).getPropertyValue('--duration')));
  </script>
</body>
</html>
