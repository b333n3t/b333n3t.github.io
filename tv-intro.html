<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>b3nn3t • Canvas-Intro (Safe Mode)</title>
<style>
  :root { --bg:#333; --duration:12000; }
  html,body{margin:0;height:100%;background:var(--bg);overflow:hidden}
  canvas{display:block;width:100vw;height:100vh;image-rendering:pixelated;image-rendering:crisp-edges}
</style>
</head>
<body>
<canvas id="stage"></canvas>
<script>
(function(){
  "use strict";

  // --- FAIL-SAFE OVERLAY: zeigt Fehler direkt im Canvas ---
  let lastError = "";
  window.addEventListener("error", e => { lastError = (e && e.message) ? e.message : String(e); });
  function drawError(ctx){
    if(!lastError) return;
    ctx.save();
    ctx.font = '14px monospace';
    ctx.fillStyle = 'rgba(255,80,80,0.95)';
    ctx.fillRect(8,8, ctx.measureText(lastError).width+16, 28);
    ctx.fillStyle = '#000';
    ctx.fillText(lastError, 16, 28);
    ctx.restore();
  }

  const canvas = document.getElementById("stage");
  const ctx = canvas.getContext("2d");

  let W=0,H=0,DPR=1;
  function PX(){ return Math.max(2, Math.floor(Math.min(W,H)/240)); }
  const lineY = () => Math.floor(H*2/3);

  function resize(){
    DPR = Math.max(1, window.devicePixelRatio || 1);
    W = canvas.width  = Math.floor(innerWidth * DPR);
    H = canvas.height = Math.floor(innerHeight * DPR);
    canvas.style.width  = innerWidth + "px";
    canvas.style.height = innerHeight + "px";
    ctx.imageSmoothingEnabled = false;
    baseX = null; // Wort wieder zentrieren
  }
  addEventListener("resize", resize); resize();

  // ---- einfache Zeichenhilfen ----
  function rect(x,y,w,h,fill){
    ctx.fillStyle = fill; ctx.fillRect(x,y,w,h);
    ctx.fillStyle = '#000';
    ctx.fillRect(x-1,y,w+2,1);
    ctx.fillRect(x-1,y+h-1,w+2,1);
    ctx.fillRect(x-1,y,1,h);
    ctx.fillRect(x+w-1,y,1,h);
  }
  function drawLine(){
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2*PX();
    ctx.beginPath(); ctx.moveTo(0,lineY()); ctx.lineTo(W*0.82,lineY()); ctx.stroke();
  }

  // ---- Avatar (selbst gezeichnet, keine externen Assets) ----
  const avatar = {
    state: 'walk',
    x: -40*PX(),
    y: lineY() - 3*PX(),
    vx: 2.1, vy: 0, gravity: .35,
    step: 0,
    hammerUntil: 0, hammerLetterIndex: -1
  };
  function drawAvatar(){
    const p=PX();
    const y=lineY(); // Füße auf Linie

    // Torso
    const bodyH=20*p, bodyW=12*p;
    const torsoX=Math.round(avatar.x-bodyW/2), torsoY=Math.round(y-bodyH-3*p);
    rect(torsoX,torsoY,bodyW,bodyH,'#2b3a56');

    // Arme (rechter Arm schlägt)
    const hammering = performance.now() < avatar.hammerUntil;
    const phase = Math.max(0, 1 - (avatar.hammerUntil - performance.now())/420);
    const armSwing = hammering ? (Math.sin(phase*Math.PI)*-2*p) : Math.sin(avatar.step)*1*p;
    rect(Math.round(avatar.x+5*p), torsoY+Math.round(3*p)+Math.round(armSwing), 3*p, 8*p, '#2b3a56');
    rect(Math.round(avatar.x-8*p), torsoY+Math.round(3*p)-Math.round(armSwing), 3*p, 8*p, '#2b3a56');

    // Beine
    const legLen=12*p, legTh=4*p, legSwing=Math.sin(avatar.step)*1*p;
    rect(Math.round(avatar.x+1*p), y - legLen + Math.round(legSwing), legTh, legLen, '#233047');
    rect(Math.round(avatar.x-4*p), y - legLen - Math.round(legSwing), legTh, legLen, '#233047');

    // Stiefel
    rect(Math.round(avatar.x+1*p), Math.round(y-3*p), 6*p, 3*p, '#7a4f1f');
    rect(Math.round(avatar.x-4*p), Math.round(y-3*p), 6*p, 3*p, '#7a4f1f');

    // Kopf (blond/blauäugig)
    const headW=18*p, headH=18*p;
    const headX=Math.round(avatar.x - headW/2);
    const headY=Math.round(torsoY - headH + 2*p);
    rect(headX, headY, headW, Math.round(headH*0.60), '#caa134');         // Haare
    rect(headX, headY + Math.round(headH*0.45), headW, Math.round(headH*0.50), '#f2b59a'); // Gesicht
    ctx.fillStyle='#1a5cff';
    ctx.fillRect(headX + Math.round(headW*0.60), headY + Math.round(headH*0.62), 2*p, 2*p);
    ctx.fillRect(headX + Math.round(headW*0.72), headY + Math.round(headH*0.62), 2*p, 2*p);

    // Hammer beim Schlag
    if (hammering){
      const hx = Math.round(avatar.x + 9*p);
      const hy = Math.round(torsoY + 6*p + Math.sin(phase*Math.PI)*6*p);
      ctx.fillStyle = '#7a4f1f'; ctx.fillRect(hx, hy, 1*p, 8*p);
      ctx.fillStyle = '#c0c0c0'; ctx.fillRect(hx-3*p, hy, 7*p, 2*p);
      ctx.fillStyle = '#000';
      ctx.fillRect(hx-3*p-1, hy, 1, 2*p);
      ctx.fillRect(hx+7*p-1, hy, 1, 2*p);
      ctx.fillRect(hx-3*p-1, hy-1, 7*p+2, 1);
      ctx.fillRect(hx-3*p-1, hy+2*p-1, 7*p+2, 1);
    }
  }

  // ---- Wort b3nn3t (zentriert, hochhämmern, Funken) ----
  const WORD = "b3nn3t";
  const LIFT_MS = 650, HAMMER_MS = 420, SPARK_COUNT = 10, LETTER_GAP_PX = 14;
  let baseX=null, nextIndexToHammer=0;
  const letters=[]; // {ch, x, y, startY, finalY, t0, hammered}

  function letterY(){ return lineY() - 18*PX(); }
  function ensureBaseX(){
    if(baseX!==null) return;
    const p=PX(), spacing=LETTER_GAP_PX*p, total=(WORD.length-1)*spacing;
    baseX = Math.round(W/2 - total/2);
  }
  function targetX(i){
    ensureBaseX(); const p=PX(), spacing=LETTER_GAP_PX*p; return baseX + i*spacing;
  }

  // Funken
  const sparks=[];
  function spawnSparks(x,y){
    const p=PX();
    for(let i=0;i<SPARK_COUNT;i++){
      const ang=Math.random()*Math.PI - Math.PI/2, spd=(0.8+Math.random()*0.8)*6*p;
      sparks.push({x,y,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd-1*p,life:450+Math.random()*250,b:performance.now(),a:1});
    }
  }
  function updSparks(){
    const now=performance.now(), p=PX();
    for(let i=sparks.length-1;i>=0;i--){
      const s=sparks[i], t=now-s.b;
      if(t>s.life){sparks.splice(i,1);continue;}
      s.vy+=0.02*p; s.x+=s.vx*0.016; s.y+=s.vy*0.016; s.a=1-(t/s.life);
    }
  }
  function drawSparks(){
    const p=PX();
    for(const s of sparks){
      ctx.globalAlpha=Math.max(0,Math.min(1,s.a));
      ctx.fillStyle='#ffd966';
      ctx.fillRect(Math.round(s.x/p)*p, Math.round(s.y/p)*p, 2*p, 2*p);
    }
    ctx.globalAlpha=1;
  }

  function maybeHammerNext(){
    if(nextIndexToHammer>=WORD.length) return;
    const idx=nextIndexToHammer, tx=targetX(idx);
    if(avatar.x >= tx){
      const p=PX(), fy=letterY();
      letters.push({ch:WORD[idx], x:tx, y:fy+10*p, startY:fy+10*p, finalY:fy, t0:performance.now(), hammered:false});
      avatar.hammerUntil = performance.now() + HAMMER_MS;
      avatar.hammerLetterIndex = idx;
      spawnSparks(tx, fy);
      nextIndexToHammer++;
    }
  }
  function updLetters(){
    const now=performance.now();
    for(const L of letters){
      if(!L.hammered){
        const t=Math.min(1,(now-L.t0)/LIFT_MS), e=1-Math.pow(1-t,3);
        L.y = Math.round(L.startY + (L.finalY - L.startY)*e);
        if(t>=1) L.hammered=true;
      }
    }
  }
  function drawLetters(){
    const p=PX();
    ctx.font=(12*p)+'px monospace'; ctx.textBaseline='middle';
    for(const L of letters){
      ctx.lineWidth=2*p; ctx.strokeStyle='#000';
      ctx.strokeText(L.ch, Math.round(L.x), Math.round(L.y));
      ctx.fillStyle='#f2f2f2';
      ctx.fillText(L.ch, Math.round(L.x), Math.round(L.y));
    }
  }

  // ---- Loop ----
  function frame(){
    try{
      ctx.clearRect(0,0,W,H);
      drawLine();

      // Buchstaben + Funken (hinter der Figur)
      maybeHammerNext();
      updLetters();
      updSparks();
      drawLetters();
      drawSparks();

      // Avatar bewegen
      const p=PX(), speed=avatar.vx*p;
      if(avatar.state==='walk'){
        avatar.x += speed;
        avatar.step += .15;
        avatar.y = lineY() - 3*p + Math.round(Math.sin(avatar.step*2)*0.4*p);
        const edgeX = W*0.82;
        if(avatar.x >= edgeX-6*p){ avatar.state='fall'; avatar.vy=0; }
      } else if(avatar.state==='fall'){
        avatar.vy += avatar.gravity*p*.6;
        avatar.y  += avatar.vy;
        avatar.x  += speed*.2;
        if(avatar.y > H + 40*p){ avatar.state='done'; }
      }

      drawAvatar();
      drawError(ctx); // zeigt Fehlertext, falls aufgetreten
      requestAnimationFrame(frame);
    }catch(err){
      lastError = err && err.message ? err.message : String(err);
      drawError(ctx);
      requestAnimationFrame(frame);
    }
  }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
