<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pixel-Marionette – Intro (b3nn3t, Hammer, Schatten)</title>
  <style>
    :root{ --bg:#333333; --duration:11000; }
    html,body{height:100%;margin:0;background:var(--bg);}
    body{overflow:hidden;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    canvas{display:block;width:100vw;height:100vh;image-rendering:pixelated;image-rendering:crisp-edges;background:var(--bg)}
  </style>
</head>
<body>
  <canvas id="stage"></canvas>

  <script>
  /* ======= Einstellungen ======= */
  const HEAD_IMG_URL     = location.origin + "/img/dein-pixel-kopf.webp?v=" + Date.now();
  const RUN_TO_RIGHT     = true;      // links -> rechts
  const CHROMA_TOLERANCE = 40;        // grauen Rand entfernen
  const WORD             = "b3nn3t";  // zu hämmerndes Wort
  const HAMMER_MS        = 380;       // Schlagdauer
  const SPARK_COUNT      = 10;        // Funken pro Schlag
  const LETTER_SIZE_PX   = 16;        // Basisschrift in PX()-Einheiten (größer als vorher)
  const LETTER_GAP_PX    = 16;        // Abstand der Buchstaben
  const HEAD_SCALE       = 26;        // Kopf größer
  const BODY_SCALE       = 16;        // Körper größer
  /* ============================= */

  const canvas = document.getElementById('stage');
  const ctx = canvas.getContext('2d');

  let W, H, DPR;
  function PX(){ return Math.max(2, Math.floor(Math.min(W,H)/240)); } // „Pixelgröße“
  const lineY = () => Math.floor(H * 2/3);
  function lineEndX(){ return Math.floor(W * 0.82); }

  function resize(){
    DPR = Math.max(1, Math.floor(window.devicePixelRatio||1));
    W = canvas.width  = Math.floor(innerWidth * DPR);
    H = canvas.height = Math.floor(innerHeight * DPR);
    canvas.style.width  = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    ctx.imageSmoothingEnabled = false;
    baseX = null; // Wort-Zentrierung beim Resize neu berechnen
  }
  addEventListener('resize', resize); resize();

  // --- Kopf laden & grauen Hintergrund entfernen ---
  function removeGrayBG(image, tolerance = CHROMA_TOLERANCE) {
    const off = document.createElement("canvas");
    off.width = image.width; off.height = image.height;
    const octx = off.getContext("2d", { willReadFrequently: true });
    octx.imageSmoothingEnabled = false;
    octx.drawImage(image, 0, 0);
    const imgData = octx.getImageData(0, 0, off.width, off.height);
    const d = imgData.data;
    const keyR = d[0], keyG = d[1], keyB = d[2]; // obere linke Ecke als Key
    for (let i = 0; i < d.length; i += 4) {
      const dr=Math.abs(d[i]-keyR), dg=Math.abs(d[i+1]-keyG), db=Math.abs(d[i+2]-keyB);
      if (dr < tolerance && dg < tolerance && db < tolerance) d[i+3] = 0;
    }
    octx.putImageData(imgData, 0, 0);
    return off;
  }
  let headReady=false, headImg=new Image(); headImg.crossOrigin='anonymous';
  headImg.onload=()=>{ headImg=removeGrayBG(headImg); headReady=true; };
  headImg.onerror=()=>{ headReady=false; };
  headImg.src = HEAD_IMG_URL;

  // --- Linie ---
  function drawLine(){
    ctx.strokeStyle='#fff';
    ctx.lineWidth = 2*PX();
    ctx.beginPath(); ctx.moveTo(0, lineY()); ctx.lineTo(lineEndX(), lineY()); ctx.stroke();
  }

  // --- kleine Helper ---
  function rect(px,py,w,h,fill){
    ctx.fillStyle=fill; ctx.fillRect(px,py,w,h);
    ctx.fillStyle='#000';
    ctx.fillRect(px-1,py,w+2,1);
    ctx.fillRect(px-1,py+h-1,w+2,1);
    ctx.fillRect(px-1,py,1,h);
    ctx.fillRect(px+w-1,py,1,h);
  }

  // --- Avatar ---
  const avatar = {
    state:'walk',
    x: RUN_TO_RIGHT ? -40*PX() : W+40*PX(),
    y: lineY() - 3*PX(),        // Stiefel-Höhe = 3*PX
    vx: RUN_TO_RIGHT ? 2.2 : -2.2,
    vy:0, gravity:.35, step:0,
    headScale:HEAD_SCALE, bodyScale:BODY_SCALE,
    hammerUntil:0
  };

  function drawHead(x,y){
    const p = PX();
    const s = avatar.headScale * p;
    const w=s, h=s;
    const top = y - avatar.bodyScale*p - s - 2*p;
    if (headReady && headImg && headImg.width){
      ctx.drawImage(headImg, Math.round(x - w/2), Math.round(top), Math.round(w), Math.round(h));
    } else {
      // minimalistischer Platzhalter
      ctx.fillStyle='#c9a23b'; ctx.fillRect(Math.round(x-w/2), Math.round(top), Math.round(w), Math.round(h*.62));
      ctx.fillStyle='#f2b59a'; ctx.fillRect(Math.round(x-w/2), Math.round(top+h*.45), Math.round(w), Math.round(h*.45));
    }
  }

  function drawBody(x,y){
    const p=PX(), bodyH=avatar.bodyScale*p, bodyW=Math.round(10*p);
    const legLen=Math.round(12*p), armLen=Math.round(9*p);
    const torsoX=Math.round(x-bodyW/2), torsoY=Math.round(y-bodyH);
    rect(torsoX,torsoY,bodyW,bodyH,'#2b3a56');

    const hammering = performance.now() < avatar.hammerUntil;
    const armTh=3*p, legTh=4*p;
    const armSwing = hammering ? (Math.sin(Math.PI)*-2*p) : Math.sin(avatar.step)*1.2*p;

    // Arme (rechts hämmert)
    rect(Math.round(x+4*p), torsoY+Math.round(3*p)+Math.round(armSwing), armTh, armLen, '#2b3a56');
    rect(Math.round(x-7*p), torsoY+Math.round(3*p)-Math.round(armSwing), armTh, armLen, '#2b3a56');

    // Beine
    const legSwing = Math.sin(avatar.step)*1.2*p;
    rect(Math.round(x+1*p), y - legLen + Math.round(legSwing), legTh, legLen, '#233047'); // vorderes
    rect(Math.round(x-4*p), y - legLen - Math.round(legSwing), legTh, legLen, '#233047'); // hinteres

    // Stiefel (Unterkante = Linie)
    rect(Math.round(x+1*p), Math.round(lineY()-3*p), 7*p, 3*p, '#7a4f1f');
    rect(Math.round(x-4*p), Math.round(lineY()-3*p), 7*p, 3*p, '#7a4f1f');

    // Hammer (nur beim Schlag)
    if (hammering){
      const hx = Math.round(x + 10*p);
      const hy = Math.round(torsoY + 7*p);
      ctx.fillStyle = '#7a4f1f'; ctx.fillRect(hx, hy, 1*p, 9*p);
      ctx.fillStyle = '#c0c0c0'; ctx.fillRect(hx-3*p, hy, 7*p, 2*p);
      ctx.fillStyle = '#000';
      ctx.fillRect(hx-3*p-1, hy, 1, 2*p);
      ctx.fillRect(hx+7*p-1, hy, 1, 2*p);
      ctx.fillRect(hx-3*p-1, hy-1, 7*p+2, 1);
      ctx.fillRect(hx-3*p-1, hy+2*p-1, 7*p+2, 1);
    }
  }

  // --- Bodenschatten beim Fallen ---
  function drawFallShadow(){
    if(avatar.state!=='fall') return;
    const p=PX();
    const baseY = lineY() + 2*p;
    const dist  = Math.max(0, avatar.y - lineY());
    const maxW  = 26*p, minW = 10*p;
    const w = Math.max(minW, maxW - dist*0.15);
    const h = Math.max(2*p, 6*p - dist*0.08);
    const alpha = Math.max(0.05, Math.min(0.35, 0.35 - dist*0.0015));
    ctx.save();
    ctx.translate(Math.round(avatar.x), Math.round(baseY));
    ctx.scale(w, h);
    ctx.beginPath();
    ctx.fillStyle = `rgba(0,0,0,${alpha.toFixed(3)})`;
    ctx.arc(0,0,1,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // --- Wort-Positionen (zentriert), Spawn nur wenn Avatar diese Position erreicht ---
  let baseX = null;
  function ensureBaseX(){
    if(baseX!==null) return;
    const p=PX(), spacing=LETTER_GAP_PX*p;
    const totalWidth = (WORD.length-1)*spacing;
    baseX = Math.round(W/2 - totalWidth/2);
  }
  function letterTargetX(i){
    ensureBaseX();
    const p=PX(), spacing=LETTER_GAP_PX*p;
    return baseX + i*spacing;
  }
  function letterTargetY(){ // leicht über Kopf
    const p=PX();
    const s=avatar.headScale*p;
    return avatar.y - avatar.bodyScale*p - s*0.35;
  }

  // --- Buchstaben-Objekte (bleiben stehen, wandern nicht) ---
  const letters=[]; // {ch,x,y}
  let nextIndexToHammer=0;

  // Funken
  const sparks=[];
  function spawnSparks(x,y){
    const p=PX();
    for(let i=0;i<SPARK_COUNT;i++){
      const ang = Math.random()*Math.PI - Math.PI/2;
      const spd = (0.8+Math.random()*0.8)*6*p;
      sparks.push({x,y,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd-1*p,life:450+Math.random()*250,born:performance.now(),alpha:1});
    }
  }
  function updateSparks(){
    const now=performance.now(), p=PX();
    for(let i=sparks.length-1;i>=0;i--){
      const s=sparks[i], t=now-s.born;
      if(t>s.life){sparks.splice(i,1);continue;}
      s.vy+=0.02*p; s.x+=s.vx*0.016; s.y+=s.vy*0.016; s.alpha=1-(t/s.life);
    }
  }
  function drawSparks(){
    const p=PX();
    for(const s of sparks){
      ctx.globalAlpha=Math.max(0,Math.min(1,s.alpha));
      ctx.fillStyle='#ffd966';
      ctx.fillRect(Math.round(s.x/p)*p, Math.round(s.y/p)*p, 2*p, 2*p);
    }
    ctx.globalAlpha=1;
  }

  function maybeHammerNext(){
    if(nextIndexToHammer >= WORD.length) return;
    const i  = nextIndexToHammer;
    const tx = letterTargetX(i);
    const ty = letterTargetY();
    const reach = 8*PX(); // Reichweite vor dem Körper

    // Spawn NUR wenn Avatar an Position ist
    if( (RUN_TO_RIGHT && avatar.x >= tx - reach) || (!RUN_TO_RIGHT && avatar.x <= tx + reach) ){
      letters.push({ch: WORD[i], x: tx, y: ty});
      avatar.hammerUntil = performance.now() + HAMMER_MS;
      spawnSparks(tx, ty);
      nextIndexToHammer++;
    }
  }

  function drawLetters(){
    const p=PX();
    ctx.font = (LETTER_SIZE_PX*p) + 'px monospace';
    ctx.textBaseline = 'middle';
    for(const L of letters){
      ctx.lineWidth = 2*p; ctx.strokeStyle = '#000';
      ctx.strokeText(L.ch, Math.round(L.x), Math.round(L.y));
      ctx.fillStyle = '#f2f2f2';
      ctx.fillText (L.ch, Math.round(L.x), Math.round(L.y));
    }
  }

  // --- Loop ---
  function tick(){
    ctx.clearRect(0,0,W,H);
    drawLine();

    // Buchstaben-Spawn an Position + Funken
    maybeHammerNext();
    updateSparks();
    drawLetters();
    drawSparks();

    // Bewegung/Fall
    const p=PX(), speed=avatar.vx*p;
    if(avatar.state==='walk'){
      avatar.x += speed;
      avatar.step += .15;
      avatar.y = lineY() - 3*p + Math.round(Math.sin(avatar.step*2) * 0.5*p);
      if( (RUN_TO_RIGHT && avatar.x >= lineEndX()-6*p) || (!RUN_TO_RIGHT && avatar.x <= lineEndX()+6*p) ){
        avatar.state='fall'; avatar.vy=0;
      }
    } else if(avatar.state==='fall'){
      avatar.vy += avatar.gravity * p * 0.6;
      avatar.y  += avatar.vy;
      avatar.x  += speed * 0.2;
      drawFallShadow();
      if(avatar.y > H + 40*p){ avatar.state='done'; }
    }

    drawBody(avatar.x, avatar.y);
    drawHead(avatar.x, avatar.y);

    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);
  </script>
</body>
</html>
